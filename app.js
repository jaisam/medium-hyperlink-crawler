const cheerio = require('cheerio');
const rp = require('request-promise');
const url = require('url');
const mongoose = require('mongoose');
const Link = require('./Models/linkModel');
require('dotenv').config();


let limit = 5;
let globalLinksArray = [];
let options = {
    method: 'GET',
    url: null,
    headers: {
        'Cookie': process.env.cookie
      }
};


// Connecting to Database
mongoose.set('useCreateIndex', true);
mongoose.connect(process.env.db_url,
    {
        useNewUrlParser: true,
        useUnifiedTopology: true
})
.then(async () => {
    console.log(`Connected to DB!`);

    // Deleting old records generated by running this script, If not done it will give unique key error
    Link.deleteMany({})
    .then(response => {
        console.log( response.n, ' records deleted of Old Crawling');

        console.log('*************** Crawling Starts ***************');
        // Main Function Call
        hyperlinkCrawler();
    })
    .catch(err => console.log(err));
})
.catch(err => {
    console.log('**** err in mongoose connect ****');
    console.log(err)
});


const createLinkObject = (url) => {
    const newUrl = new URL(url);
    const linkObj = { 
        url : newUrl.origin + newUrl.pathname,
        count : 1,
        params : []
    };
    newUrl.searchParams.forEach((value, property) => {
        linkObj.params.push(property);
    });
    return linkObj;
}


// Helper Function
const crawlAndPersistUrl = async (linkObjects) => {
    let promises = [];
    Object.values(linkObjects).forEach(obj => {
        promises.push(
            new Promise(function (resolve, reject) {
                let paramMismatch = false;

                Link.findOne({
                    url: obj.url
                })
                .then((dbLinkObj) => {
                    let dbPromise;

                    if(dbLinkObj) {
                        // Update old object  
                        dbLinkObj.count += obj.count;
                        obj.params.forEach(param => {
                            if(!dbLinkObj.params.includes(param)) {
                                dbLinkObj.params.push(param);
                                paramMismatch = true;
                            }
                        });
                        dbPromise = dbLinkObj.save();
                    } else {
                        // Create new object
                        paramMismatch = true;
                        dbPromise = Link.create(obj);
                    }

                    return dbPromise;
                    })
                    .then(record => {
                        if(paramMismatch){
                            options.url = obj.url;
                            return rp(options)
                            .then(response => {
                                const $ = cheerio.load(response);
                                const anchortags = $('a');
                                $(anchortags).each(function(i,tag){
                                    const link = $(tag).attr('href');
                                    if(link.startsWith('https://medium.com')) {
                                        globalLinksArray.push(link);
                                    }
                                });
                                return resolve();
                            })
                        }
                        else {
                            return resolve();
                        }
                    })
                .catch(err => {
                    console.log('******** err in crawlAndPraseUrl ********');
                    console.log(err);
                    return reject(err);
                })
            })
        );
    }) 
    return Promise.all(promises);
};


// Driver Function
const hyperlinkCrawler = async (url) => {
    let linkObjects = {};
    let batch_count = 0;
    globalLinksArray.push(process.env.url);
    
    for(let i = 0 ; i <= globalLinksArray.length ; i++){
        if(Object.keys(linkObjects).length >= limit || i == globalLinksArray.length ) { 
            await crawlAndPersistUrl(linkObjects); 

            // Clearing data
            i--;
            linkObjects = {};
            batch_count++;
            console.log('Batch ' + batch_count + ' processed!');
            console.log('Links remaining to be Parsed : ' + (globalLinksArray.length - i));
        }
        else { 
            const linkObj = createLinkObject(globalLinksArray[i]);

            if(linkObjects[linkObj.url]) {
                linkObjects[linkObj.url].count++;
            } 
            else {
                linkObjects[linkObj.url] = linkObj;
            }
        }
    } 
};
