const cheerio = require('cheerio');
const axios = require('axios');
const url = require('url');
const mongoose = require('mongoose');
const Link = require('./Models/linkModel');
const { db } = require('./Models/linkModel');
const { resolve } = require('path');
require('dotenv').config();

let limit = 5;
let globalLinksArray = [];
let globalLinksObjectArray = [];


// Connecting to Database
mongoose.connect(process.env.db_url,
    {
        useNewUrlParser: true,
        useUnifiedTopology: true
})
.then(async () => {
    console.log(`Connected to DB!`);

    // Deleting old records generated by running this script, If not done it will give unique key error
    Link.deleteMany({})
    .then(response => {
        console.log('No of Deleted Records ', response.n);

        // Main Function Call
        hyperlinkCrawler();
    })
    .catch(err => console.log(err));
})
.catch(err => {
    console.log('**** err in mongoose connect ****');
    console.log(err)
});


// Helper Function
const crawlAndParseUrl = (url) => { 
    console.log('Inside crawlAndPraseUrl');
    return new Promise(function (resolve, reject) {
        return axios.get(url)
        .then(response => {
            const $ = cheerio.load(response.data);
            const anchortags = $('a');
            $(anchortags).each(function(i,tag){
                const link = $(tag).attr('href');
                if(link.startsWith('https://medium.com')) {
        
                    // Create URL Object
                    const newUrl = new URL(link);
                    const linkObj = { 
                    url : newUrl.origin + newUrl.pathname,
                    count : 1,
                    params : []
                    };
                    newUrl.searchParams.forEach((value, property) => {
                        linkObj.params.push(property);
                    });
        
                    // Check if object exists
                    let existingLinkObj = globalLinksObjectArray.find(object => {
                        if(object.url == linkObj.url){
                            return object;
                        }
                    });
        
                    let paramMismatch = false;
                    if(existingLinkObj){
                        // Update old object  
                        existingLinkObj.count++;
                        linkObj.params.forEach( param => {
                            if(!existingLinkObj.params.includes(param)) {
                                existingLinkObj.params.push(param);
                                paramMismatch = true;
                            }
                        }); 
                    } else {
                        // Insert newly created Object
                        globalLinksObjectArray.push(linkObj);
                        paramMismatch = true;
                    }
        
                    if(paramMismatch) globalLinksArray.push(link);
                }
            });

            console.log('************** globalLinksArray **************', globalLinksArray);
            console.log('************** globalLinksObjectArray **************', globalLinksObjectArray);
            console.log('Return back to hypercraler');
            return resolve();
        })
        .catch(err => {
            console.log('******** err in crawlAndPraseUrl ********');
            console.log(err);
            return reject(err);
        })
    });
};


const persistData = async () => {
        let dbPromises = [];
        console.log('Inside persistData');
        for(let i = 0 ; i < globalLinksObjectArray.length; i++){
            dbPromises.push(
                Link.findOne({
                    url: globalLinksObjectArray[i].url
                })
                .then((dbLinkObj) => {
                    let dbPromise;
                    
                    console.log('----------------------------------------');
                    console.log('Start First then ', globalLinksObjectArray[i].url);
                    // console.log('dbLinkObj ', dbLinkObj);
        
                    if(dbLinkObj) {
                        // Update old object  
                        dbLinkObj.count++;
                        globalLinksObjectArray[i].params.forEach( param => {
                            if(!dbLinkObj.params.includes(param)) {
                                dbLinkObj.params.push(param); 
                            }
                        });
                        dbPromise = dbLinkObj.save();
                        // console.log('Saving Object', dbPromise);
                    } else { 
                        dbPromise = Link.create(globalLinksObjectArray[i]);
                        // console.log('Creating Object ', dbPromise);
                    }
                    
                    console.log('Before return dbPromise ', globalLinksObjectArray[i].url);
        
                    return dbPromise;
                })
                .then(record => { 
                    // console.log('record =>', record); 
                    console.log('End of persistData');
                    return resolve();
                })
                .catch(err => {
                    console.log('******** err in persistData ********');
                    console.log(err);
                    return reject(err);
                })
            );
        }
        await Promise.all(dbPromises);
}


// Driver Function
const hyperlinkCrawler = async (url) => {
    let  urlPromisesList = [];
    globalLinksArray.push(process.env.url);
    
    for(let i = 0 ; i <= globalLinksArray.length ; i++){
        if( urlPromisesList.length >= limit || i == globalLinksArray.length ) {
            console.log('####### Inside ELSE ####### i is ' + i + ' globalLinksArray.length ' + globalLinksArray.length);
            const response = await Promise.all(urlPromisesList);
            console.log('After promise.all');
            await persistData();
            console.log('After persistData : i ' + i + ' globalLinksArray.length ' + globalLinksArray.length );
            i--;
            urlPromisesList = [];
        }
        else {
            urlPromisesList.push(crawlAndParseUrl(globalLinksArray[i]));
            console.log('******** Inside IF ***** i is ' + i + ' globalLinksArray.length ' + globalLinksArray.length);
        }
    }
    console.log('Outside for loop');
};
